### load {#id-第一节CPU-load}

Linux的Load\(系统负载\)，是一个让新手不太容易了解的概念。load的就是一定时间内计算机有多少个active\_tasks，也就是说是计算机的任务执行队列的长度，cpu计算的队列。

top/uptime等工具默认会显示1分钟、5分钟、15分钟的平均Load。评估系统性能时，不仅仅看load average的数值，而且应该结合系统的CPU核数，系统的负载均值是基于内核的数量决定的，例如该服务器有24核，则单核的CPU负载为7/24。

依据经验分析，单核CPU负载&lt;2时，系统性能是良好的，当单核CPU负载&gt;5时，那么就表明这个机器存在严重的性能问题。 

具体来说，平均Load是指，在特定的一段时间内统计的正在CPU中运行的\(R状态\)、正在等待CPU运行的、处于不可中断睡眠的\(D状态\)的任务数量的平均值。

最后，说一下CPU使用率和Load的关系吧。如果主要是CPU密集型的程序在运行\(If CPU utilization is near 100 percent \(user + nice  +  system\), the workload sampled is CPU-bound.\)，那么CPU利用率高，Load一般也会比较高。而I/O密集型的程序在运行，

可能看到CPU的%user, %system都不高，%iowait可能会有点高，这时的Load通常比较高。

同理，程序读写慢速I/O设备\(如磁盘、NFS\)比较多时，Load可能会比较高，而CPU利用率不一定高。这种情况，还经常发生在系统内存不足并开始使用swap的时候，Load一般会比较高，而CPU使用率并不高。

### 用户态user 系统态system {#id-第一节CPU-用户态user系统态system}

  
在CPU的所有指令中，有一些指令是非常危险的，如果错用，将导致整个系统崩溃。比如：清内存、设置时钟等。所以，CPU将指令分为特权指令和非特权指令，对于那些危险的指令，只允许操作系统及其相关模块使用，普通的应用程序只能使用那些不会造成灾难的指令。  
**系统态（内核态）**：当一个任务（进程）执行系统调用而陷入内核代码中执行时，我们就称进程处于内核运行态（或简称为内核态）。此时处理器处于特权级最高的（0级）内核代码中执行。当进程处于内核态时，执行的内核代码会使用当前进程的内核栈。每个进程都有自己的内核栈。  
**用户态**：当进程在执行用户自己的代码时，则称其处于用户运行态（用户态）。即此时处理器在特权级最低的（3级）用户代码中运行。  
**用户态与内核态的区别：**

1. 内核态可以执行任何指令程序，用户态只能执行特定指令
2. 内核态代码可以自由访问任何有效地址，用户态的代码则要受到处理器的诸多检查，它们只能访问映射其地址空间的页表项中规定的在用户态下可访问页面的虚拟地址

**用户态与内核态转换：**  
在内核态下CPU可执行任何指令，在用户态下CPU只能执行非特权指令。当CPU处于内核态，可以随意进入用户态；  
而当CPU处于用户态时，用户从用户态切换到内核态只有在**系统调用和中断两种情况**下发生，一般程序一开始都是运行于用户态，当程序需要使用系统资源时，就必须通过调用软中断进入内核态。



### 上下文切换（Content Switch） {#id-第一节CPU-上下文切换（ContentSwitch）}

每个进程都会分到CPU的时间片来运行，当一个进程用完时间片或者被更高优先级的进程抢占后，它会\*备份\*到CPU的运行队列中，同时其他进程在CPU上运行。这个进程切换的过程被称作上下文切换。过多的上下文切换会造成系统很大的开销。  
上下文切换过程中执行的操作：

* 挂起一个进程，并储存该进程当时在内存中所反映出的状态
* 从内存中恢复下一个要执行的进程，恢复该进程原来的状态到寄存器，返回到其上次暂停的执行代码然后继续执行

Context Switch大体上由两个部分组成：中断和进程\(包括线程\)切换，一次中断（Interrupt）会引起一次切换，进程（线程）的创建、激活之类的也会引起一次切换。



